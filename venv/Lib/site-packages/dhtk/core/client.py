"""Module for setting up and connecting to triplestore"""
# Import dependencies modules
import dhtk.core.system as core
import dhtk.extensions as ext
import pathlib
import platform
import re
import sys
import socket
import logging
import docker
import contextlib
import tqdm
import subprocess
import time
import typing
import warnings

warnings.formatwarning = lambda message, *args: f"{message}\n"


class Client:
    """Class to manage DHTK connection to the triplestore endpoint.

    Instantiates an object to connect to the required triplestore.
    If the triplestore is local, it sets up a Fuseki container on Docker.
    """

    def __init__(self, settings: object, install: bool = False):
        """Instantiation of  DHTK Client object.

        Parameters
        ----------
        settings: DHTK Settings object
            Configurations to use
        install: boolean [default: False]
            If True, DHTK will try to install Docker automatically
        """

        # Retrieve required DHTK settings
        endpoint = settings.endpoint
        self.LOGS = settings.logger
        self.wd = settings.wd
        self.dataset = settings.dataset
        self.port = settings.port

        self.LOGS.info("CLIENT: Instantiating Client object")

        self.os = platform.system()
        self.client = None
        if endpoint.startswith("local"):
            # Check and set up local client
            self._check_docker(install)

            # If _correct_credsstore was run before, there should be a backup file
            bkup = pathlib.Path("~/.docker/config_bkup.json").expanduser()
            if not bkup.is_file():
                self._correct_credsstore()  # Correct the Docker configuration

            settings._connect = self._connect(wait=settings._connect)

            # Once connected to Docker, check required containers
            self._check_images(images=["busybox", "myclassunil/jena-fuseki"])
            containers = self._default_containers()
            self._check_containers(containers)
        else:
            self.client = endpoint

        # Save any changes to settings
        settings.port = self.port
        settings.save()

        # Failed all attempts for self._connect
        if self.client is None:
            msg = "Docker initiation timed-out!"
            self.LOGS.error("CLIENT: " + msg)
            warnings.warn(msg)
            print("Please start Docker app manually and restart DHTK")
            sys.exit()

        self.LOGS.info("CLIENT: Instantiation complete")

    def get_objects(self, types: typing.Union[str, typing.List[str]] = ("images", "containers", "volumes")) -> dict:
        """Method to check stored configurations for triplestore endpoint.

        Parameters
        ----------
        types [string/list]:
            Types of Docker "object" to get

        Returns
        -------
        Docker objects available
        """
        self.LOGS.debug(f"CLIENT: Client.get_objects(types={types}) method was called")

        # Ensure a list is passed
        if isinstance(types, str):
            types = [types]
        objects = {}

        if "images" in types:
            objects["images"] = self.client.images.list()
        if "containers" in types:
            objects["containers"] = self.client.containers.list(all=True)
        if "volumes" in types:
            objects["volumes"] = self.client.volumes.list()

        return objects

    def _connect(self, wait: int = 30) -> int:
        """Method to connect to local Docker client

        Parameters
        ----------
        wait: integer [default = 30]
            Number of seconds to wait between each attempt to connect
        """
        self.LOGS.debug(f"CLIENT: Client._connect(wait={wait}) method was called")

        # Loop until connection is establish to docker client (timeout just in case)
        lapsed_time = -1
        done = self._get_client()

        for attempt in range(1, 6):

            if not done:
                if self.os == "Windows" or self.os == "Darwin":
                    subprocess.check_call(["open", "-a", "docker"])

                for _ in tqdm.trange(wait, desc=f"Connecting to docker ({attempt}/5)"):

                    # Wait for the bar to complete
                    if not done:
                        done = self._get_client()
                        time.sleep(1)
                        lapsed_time += 1

            if done and lapsed_time == -1:
                lapsed_time = wait

        # Set a better estimate for the user's machine
        return lapsed_time

    def _get_client(self):
        """Method to retrieve a connection to local Docker application

        Returns
        -------
        A docker.client.DockerClient object
        """

        try:
            client = docker.from_env()
            self.client = client
            return True
        except docker.errors.DockerException:  # If connection to Docker app is not open
            return False

    def _update(self, datasets: typing.List[str] = None) -> None:
        """Method to update dhtk-app container from Docker.
        It removes and re-installs the container with considering
        the new dataset extensions available

        Parameters
        ----------
        datasets: list of strings
            List of datasets to be added to dhtk-app on the Fuseki server
        """
        self.LOGS.debug(f"CLIENT: Client._update() method was called")

        self.client.containers.get("dhtk-app").stop()
        self.client.containers.get("dhtk-app").remove(force=True)

        containers = self._default_containers(datasets)

        self._check_containers(containers)

    # Methods to check Docker is ready
    def _check_docker(self, install: bool = False) -> None:
        """Method to check if Docker is installed.

        Parameters
        ----------
        install: boolean [default: False]
            If True, DHTK will try to install Docker automatically
        """
        self.LOGS.debug("CLIENT: Client._check_docker() method was called")

        # Check Docker version as proxy for installation
        version = None
        while not version:
            try:
                if self.os == "Windows":
                    version = subprocess.check_output("docker version")
                    install = False
                elif self.os == "Darwin" or self.os == "Linux":
                    docker_executable = subprocess.check_output(["which", "docker"]).decode('ascii').rstrip()
                    version = subprocess.check_output([docker_executable, "--version"])
                    install = False
                else:
                    warnings.warn("No common OS detected!")

            except (subprocess.CalledProcessError,docker.errors.DockerException):

                if install:  # If installation is to be attempted
                    msg = "Trying to install Docker automatically"
                    print(msg)
                    self.LOGS.info("CLIENT: " + msg)
                    Installers(self.os, self.LOGS)
                else:
                    msg = "No Docker application detected"
                    self.LOGS.error("CLIENT: " + msg)
                    warnings.warn(msg)
                    raise EnvironmentError(
                        "Please start docker. " +
                        "And make sure your user has the rights to access to docker. " +
                        "You may need to install Docker from https://docs.docker.com/get-docker/"
                    )

    def _check_images(self, images: typing.List[str]) -> None:
        """Method to check if the local Docker client has the requested images installed.
        If not, pull the requested images.

        Parameters
        ----------
        images: list of strings
            List of Docker images required by DHTK
        """
        self.LOGS.debug(f"CLIENT: Client._check_images(images={images}) method was called")

        # Get images already installed
        available = self.get_objects(types="images")
        available = [image.tags[0] for image in available["images"] if image.tags]  # Remove empty images

        for img in images:
            if img + ":latest" not in available:
                msg = f"{img} image not found: Pulling latest image."
                self.LOGS.debug(f"CLIENT: {msg}")
                print(msg)
                self.client.images.pull(repository=img, tag="latest")

    def _check_containers(self, containers: typing.List[dict]) -> None:
        """Method to check if the local Docker has the required containers set up.
        If not, set up required containers.

        Parameters
        ----------
        containers: list of dictionaries
            List of dictionaries describing the Docker containers required by DHTK
        """
        self.LOGS.debug(f"CLIENT: Client._check_containers(containers={containers}) method was called")

        available = self.get_objects(types="containers")
        available = [container.name for container in available["containers"]]  # Remove empty containers

        for container in containers:

            if container["name"] not in available:
                msg = f"{container['name']} container not found: Set to image {container['image']}"
                self.LOGS.debug(f"CLIENT: {msg}")
                print(msg)

                if container["ports"] == {f"{self.port}/tcp": self.port}:
                    port = self._check_ports(available)
                    self.port = port
                    container["ports"] = {f"3030/tcp": self.port}

                self.client.containers.run(
                    image=container["image"],
                    name=container["name"],
                    ports=container["ports"],
                    environment=container["environment"],
                    detach=container["detach"],
                    volumes_from=container["volumes_from"],
                    volumes=container["volumes"]
                )

                self.client.containers.get(container["name"]).stop()

        self._check_app()

    def _check_ports(self, containers):
        """Method to check if Docker's "localhost" port is available

        Parameters
        ----------
        containers: list of strings
            List of the names of containers available on local Docker

        Returns
        -------
        An integer for an available port number
        """

        used_ports = []
        # Get all ports already used by Docker containers
        for container in containers:
            app = self.client.containers.get(container)
            port = app.attrs["HostConfig"]['PortBindings']
            if port:
                port = list(port.keys())[0].split("/")[0]
                used_ports.append(int(port))

        port = self.port

        # Bind a random port
        with contextlib.closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as s:
            while port in used_ports:
                s.bind(('', 0))
                port = s.getsockname()[1]
        s.close()
        return port

    def _check_app(self) -> None:
        """Method to check if the Fuseki app contains the dataset to load
        on its environment
        """
        self.LOGS.debug(f"CLIENT: Client._check_app() method was called")

        app = self.client.containers.get("dhtk-app")
        app_env = app.attrs["Config"]["Env"]

        fuseki_datasets = [re.sub("FUSEKI_DATASET_.*=", "", dataset) for dataset in app_env
                           if dataset.startswith("FUSEKI_DATASET")]

        # If extension is not available on Fuseki, update the container
        if not (self.dataset.lower() in fuseki_datasets or 'dhtk-extension-' + self.dataset.lower() in fuseki_datasets):
            self.LOGS.debug(f"CLIENT: extension not on Fuseki's environent")
            print("Updating Fuseki with the new extension")
            self._update(datasets=fuseki_datasets)

    @staticmethod
    def check_modules():
        """Method to check the available extensions (datasets).

        Returns
        -------
        List DHTK extension sub-modules available
        """

        # Read from available file
        available = ext.modules
        available = [line.lower().strip() for line in available]
        return available

    # Defaults
    def _default_containers(self, datasets: typing.List[str] = None) -> typing.List[dict]:
        """Method to retrieve the default containers required by DHTK

        Parameters
        ----------
        datasets: list of strings
            List of datasets to be added to dhtk-app on the Fuseki server

        Returns
        -------
        A list containing the dictionaries describing the Docker containers required for DHTK
        """
        self.LOGS.debug(f"CLIENT: Client._default_containers(datasets={datasets}) method was called")

        # Detect available extension modules
        if datasets is None:
            datasets = []
        datasets += self.check_modules()
        # Remove duplicated values (those already in Fuseki's environment)
        datasets = list(set(datasets))

        # Since all extensions should be called dhtk-extension-, add flexibility to the check
        if not (self.dataset.lower() in datasets or 'dhtk-extension-' + self.dataset.lower() in datasets):
            msg = "Dataset called is not available!"
            self.LOGS.error(f"CLIENT: " + msg)
            raise NotImplementedError(msg + f"\nAvailble datasets:\n{datasets}")

        datasets = [f"FUSEKI_DATASET_{i + 1}={datasets[i]}" for i in range(len(datasets))]

        # Generate required containers
        containers = [{"name": "dhtk-data",
                       "image": "busybox:latest",
                       "ports": None,
                       "environment": None,
                       "detach": False,
                       "volumes_from": None,
                       "volumes": {"fuseki": {"bind": "/fuseki"}}},

                      {"name": "dhtk-app",
                       "image": "myclassunil/jena-fuseki:latest",
                       "ports": {f"{self.port}/tcp": self.port},
                       "environment": ["ADMIN_PASSWORD=pw123"] + datasets,
                       "detach": True,
                       "volumes_from": ["dhtk-data"],
                       "volumes": {self.wd: {"bind": "/staging"}}}
                      ]

        return containers

    def _correct_credsstore(self) -> None:
        """
        credsStore value in .docker/config.json was troublesome during testing,
        this method removes it from Docker configuration allowing DHTK to work normally.
        """
        # If the credsStore line doesn"t exist, the command throws an error and its ignored
        path = pathlib.Path('~/').expanduser()
        file = ""
        line = ""

        try:
            if self.os == "Windows":
                path = path.__str__().replace('\\', '/')
                line = subprocess.check_output(f'findstr /n /d:{path}/.docker /c:credsStore *.json', shell=True)
            elif self.os == "Darwin":
                line = subprocess.check_output('grep -n "credsStore" ~/.docker/config.json', shell=True)
            elif self.os == "Linux":
                pass
        except subprocess.CalledProcessError:
            print("credsStore already corrected. This is ok, but shouldn't really happen!")
            return None

        # Set up a backup
        if self.os == "Darwin":
            subprocess.check_call("cp ~/.docker/config.json ~/.docker/config_bkup.json", shell=True)
            # Correct entry
            line = re.sub("b'", "", str(line).split(":")[0])
            file = subprocess.check_output(f'sed "{line}d" ~/.docker/config.json', shell=True)
            file = file.decode("utf-8")

        # Modify file
        with open("./config.json", "w") as f:
            f.writelines(file)

        # Replace configs
        if self.os == "Linux":
            return
        elif self.os == "Windows":
            # Set up a backup file
            path = pathlib.Path('~/').expanduser()
            subprocess.check_call(f"copy {path}\\.docker\\config.json {path}\\.docker\\config-bkup.json", shell=True)
            subprocess.check_call(f"move config.json {path}\\.docker\\config.json", shell=True)
        elif self.os == "Darwin":
            # Set up a backup file
            subprocess.check_call("cp ~/.docker/config.json ~/.docker/config_bkup.json", shell=True)
            subprocess.check_call("mv ./config.json ~/.docker/config.json", shell=True)

        # Kill Docker and for methods to be properly killed
        if self.os != "Windows":
            subprocess.check_call(["killall", "Docker"])
        else:
            candidates_list = ['Docker Desktop.exe']
            task_list = []
            for candidate in candidates_list:
                task_list.append(subprocess.check_output(f'tasklist /fi "IMAGENAME eq {candidate}"', shell=True).decode('utf-8'))
            pids = []
            for task in task_list:
                elements = task.split(' ')
                for el in elements:
                    if len(el) > 1 and el.isnumeric():
                        pids.append(int(el))
            for pid in pids:
                try:
                    subprocess.check_call(f'taskkill /PID {pid}', shell=True)
                except subprocess.CalledProcessError:
                    print(f'Cannot kill process Docker Desktop process (PID: {pid}) automatically')
        time.sleep(10)

    def __delete__(self, instance):
        docker.stop("dhtk-app")

    def __exit__(self, exc_type, exc_val, exc_tb):
        docker.stop("dhtk-app")


class Installers:
    """
    Class wrapper for Docker installation procedures
    """

    def __init__(self, os: str, logs: logging.Logger) -> None:
        """
        Instantiation of Installers object.

        Parameters
        ----------
        logs: logging.Logger object
            Logger object to manage DHTK logs
        """
        logs.debug("INSTALLERS: Instantiating Endpoint object")

        if os == "Darwin":  # Darwin is code for Mac
            logs.debug(f"INSTALLERS: Operating system: {os}")
            self._docker_mac(logs=logs)
        else:

            msg = f"""Docker installation is not automated for this operating system: {os}:
            If docker is already installed on yous system, please make sure:
            - that it is running
            - that the user you are using has permission to use docker.
            If not, please install docker: https://docs.docker.com/get-docker/
            """
            logs.error("INSTALLERS: " + msg)
            raise EnvironmentError(msg)

    # Installers
    def _docker_mac(self, logs: logging.Logger) -> None:
        """Method to create Docker installation pipeline on MacOS systems

        Parameters
        ----------
        logs: logging.Logger object
            Logger object to manage DHTK logs
        """
        # Log call
        logs.debug(f"INSTALLERS: Installers._docker_mac() method was called")
        warnings.warn("DHTK installs the Docker engine from the DMG distribution")
        print("If you would rather use another method (e.g. through Homebrew), "
              + "\nthen please abort and install Docker yourself.")
        input("Press ENTER to continue or CTRL-C to abort")

        url = "https://desktop.docker.com/mac/stable/Docker.dmg"  # MacOS file URL
        file = core.download_files(urls=url, name=f"Downloading Docker")

        # Define the installation pipeline
        pipeline = [  # 1) Attach image
            ["hdiutil", "attach", file],
            # 2) Copy application (may needs admin permission)
            ["cp", "-rf", "/Volumes/Docker/Docker.app", "/Applications"],
            # 3) Detach image
            ["hdiutil", "detach", "/Volumes/Docker/"],
            # 4) Remove downloaded file
            ["rm", file],
            # 5) It is best to open Docker to set up properly (it might needs verification)
            ["open", "-a", "docker"]
        ]
        self._run_pipeline(pipeline, logs)

        time.sleep(10)
        input("Press ENTER when ready")

    @staticmethod
    def _run_pipeline(pipeline: typing.List, logs: logging.Logger) -> None:
        """Method to install Docker application

        Parameters
        ----------
        pipeline: list
            System specific commands to call for Docker installations
        logs: logging.Logger object
            Logger object to manage DHTK logs
        """

        for step in tqdm.tqdm(pipeline, desc="Installing Docker"):
            try:
                logs.debug(f"INSTALLERS: Trying to call {step}")
                subprocess.check_call(step)
            except (subprocess.CalledProcessError, FileNotFoundError):
                msg = [f"User does not seem to have permission to run: {' '.join(step)}",
                       "Please install Docker from https://docs.docker.com/get-docker/"]
                msg = "\n".join(msg)
                logs.error(f"INSTALLERS: {msg}")
                sys.exit(msg)
