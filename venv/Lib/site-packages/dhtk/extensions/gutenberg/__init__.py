"""Gutenberg extension module"""
from dhtk.extensions.blueprint import AbstractExtension
from dhtk.extensions.gutenberg.api.data import GutenbergData
from dhtk.extensions.gutenberg.api.corpus import GutenbergCorpus
from urllib.error import URLError
import warnings
from http.client import RemoteDisconnected
import pickle
from time import sleep
import re
from dhtk.core.system import make_dirs

warnings.formatwarning = lambda message, *args: f"{message}\n"


class Module(AbstractExtension):
    """Gutenberg Triplestore Class"""

    def __init__(self, settings, client):
        super().__init__(settings, client)

        # Defaults required to be defined for each extension
        self.name = "gutenberg"
        self.url = "https://sandbox.zenodo.org/record/709580/files/gutenberg_reasoned_final.ttl?download=1"

        # Instantiate a Corpus
        self._corpus = GutenbergCorpus(name=f"{self.name.capitalize()} Corpus",
                                       description="Gutenberg Books",
                                       settings=settings)
        self._check_endpoint()

        # Get the extension
        self.wrapper = GutenbergData(sparql_endpoint=self.ENDPOINT, logs=self.LOGS)

    def welcome(self):

        for check in range(10):
            try:
                stats = self.wrapper.statistics()
                break
            except (RemoteDisconnected, URLError, ConnectionResetError):
                if check >=9:
                    warnings.warn("WARNING: There is a problem with the connection!")
                    print("Probably Docker is slow to restart!")
                    stats = "\nNo statistics available"
                    break
                sleep(10)

        timestamp = self.CONFIGS.modules.get('gutenberg', None)
        if timestamp is None:
            print(f"\nDHTK Gutenberg statistics:{stats}")
        else:
            timestamp = timestamp.strftime("%d %b %Y")
            #TODO: add remote update date as well?
            print(f"\nDHTK Gutenberg statistics:\nLast local update: {timestamp}{stats}")

    def get(self, what, name="all", add=False):
        """
        Extension wrapper method to call all DHTK functionalities with a simple syntax

        Parameters
        ----------
        what: string
            Type of information to retrieve.
            DHTK Gutenberg has the options to search for books, authors, shelves and subjects
        name: string [default: "all"]
            Name identifying the specific information to retrieve.
            If all, retrieve all information available
        add: boolean [default: False]
            Add query results to Corpus

        Returns
        -------
        Requested book information from Gutenberg dataset
        """

        # Prepare arguments
        name = name.strip().lower()
        what = what.strip().lower()

        if what.startswith("bo"):
            if name == "all":
                response = self.wrapper.all_books()
            else:
                response = self.wrapper.search_by_title(name)
                response = [self.wrapper.get_book(book["book_id"]) for book in response]

                if add:
                    self._corpus.add_books(response)

                # Use a short book title
                response = {f"{book.get_title()[:20]} ({book.get_book_id_number()})": book for book in response}

        elif what.startswith("au"):
            if name == "all":
                response = self.wrapper.all_authors()
            else:
                response = self.wrapper.search_by_author(name)
                ids = set([author["author_id"] for author in response])
                response = [self.wrapper.get_author(author) for author in ids]

                if add:
                    for author in response:
                        for book in author.get_bibliography():
                            books = self.get(what="book", name=book)

                            books = {title:book for title,book in books.items() if book.get_author() == author}

                            # Match short book key name
                            stitle = re.sub("\s+", " ", book[:20])
                            books = [book for key, book in books.items() if stitle in key]

                            self._corpus.add_books(books)

                response = {f"{author.get_full_name()}": author for author in response}

        elif what.startswith("sh"):
            if name == "all":
                response = self.wrapper.all_bookshelves()
            else:
                response = self.wrapper.search_by_bookshelf(name)
                if add:
                    add = [self.wrapper.get_book(book["book_id"]) for book in response]
                    self._corpus.add_books(add)

                results = dict()
                for shelf in response:
                    book = f"{shelf['title']} [{shelf['author']}]"
                    results[shelf['bookshelf']] = results.get(shelf['bookshelf'], [])

                    if book not in results[shelf['bookshelf']]:
                        results[shelf['bookshelf']] += [book]

                response = results

        elif what.startswith("su"):
            if name == "all":
                response = self.wrapper.all_subjects()
            else:
                response = self.wrapper.search_by_subject(name)

                if add:
                    add = [self.wrapper.get_book(book["book_id"]) for book in response]
                    self._corpus.add_books(add)

                results = dict()
                for subject in response:
                    book = f"{subject['title']} [{subject['author']}]"
                    results[subject['subject']] = results.get(subject['subject'], [])

                    if book not in results[subject['subject']]:
                        results[subject['subject']] += [book]

                response = results


        else:
            warnings.warn("Not a valid option")
            print("Allowed arguments are:\nbook\nauthor\nshelf\nsubject")
            return

        if not response:
            response = "\n".join([f"No {what} found.",
                                  "Please make sure there are no spelling mistakes.",
                                  "You may search all available options by ignoring the [name] argument"])
            print(response)
            return
        else:
            return response

    def corpus(self, name=None, description=None):
        if name is not None:
            self._corpus.name(name)
        if description is not None:
            self._corpus.description(description)

        return self._corpus

    def save(self, close=True):

        # Prepare save directory
        path = self._corpus.path()

        if not path.is_dir():
            make_dirs(path)

        # Save Gutenberg Texts
        self._corpus.download_corpus()

        # Save metadata table
        self._corpus.download_metadata()

        # Save Python Query Object
        with open(path / "corpus.pk", 'wb') as pickled_file:
            pickle.dump(self._corpus.to_pandas_dataframe(), pickled_file, protocol=pickle.HIGHEST_PROTOCOL)
        pickled_file.close()

        if close:
           self.close()

