"""Contains the GutenbergData implementation of the abstract LiteraryData class"""

# Import dependencies
import re
from SPARQLWrapper import SPARQLWrapper, JSON
from dhtk.extensions.templates.data import Data
from dhtk.extensions.gutenberg.tools.author import GutenbergAuthor
from dhtk.extensions.gutenberg.tools.book import GutenbergBook


class GutenbergData(Data):
    """Class to searching the Gutenberg catalog using SPARQL queries,
    inheriting from the Abstract class LiteraryData (dhtk.extensions.abstract_gutenberg)

    "Query" attributes participate to create a skeleton of a standard query :
        query_header + query_select + query_head.

    Parameters
    ----------
    sparql_endpoint: str
        URL of the triplet store containing Gutenberg Catalog triplets.

    Attributes
    ----------
    _query_header_: str
        Declarations of ontologies as a concatenate string in the SPARQL language.
    _query_select: str
        Declarations of searched variables as a concatenate string in the SPARQL language.
    _query_head: str
        Declarations of relations between variables and ontologies as a concatenate string in
        the SPARQL language.

    Example
    --------
    ::

        from pprint import pprint
        from dhtk.catalogs.gutenberg.data import GutenbergData

        gutenberg_data = GutenbergData("http://dhtk.unil.ch/gutenberg/sparql")

    """
    # TODO: implement different types than text! '?book_id dcterms:type dcmitype:Text.'
    # TODO: add method to search book when author is known.

    _namespace = "\n".join([
        "PREFIX dcterms: <http://purl.org/dc/terms/>",
        "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>",
        "PREFIX purl: <http://purl.org/dc/terms/>",
        "PREFIX owl: <http://www.w3.org/2002/07/owl#>",
        "PREFIX pgterms: <http://www.gutenberg.org/2009/pgterms/>",
        "PREFIX foaf: <http://xmlns.com/foaf/0.1/>",
        "PREFIX marcrel: <http://id.loc.gov/vocabulary/relators/>",
        "PREFIX dcmitype: <http://purl.org/dc/dcmitype/>\n",
    ])

    _work_types = [
        "Text",
        "Image",
        "Sound",
        "Dataset",
        "StillImage",
        "Collection",
        "MovingImage",
    ]

    _search_cache = dict()

    _book_metadata = ("""<%s> rdf:type ?gutenberg_type . """,
                      "<%s> pgterms:downloads ?gutenberg_downloads .",
                      "<%s> dcterms:publisher ?gutenberg_publisher .",
                      "<%s> dcterms:hasFormat ?gutenberg_hasFormat .",
                      """<%s> dcterms:language [rdf:value ?gutenberg_language] .""",
                      """<%s> dcterms:subject  [rdf:valuowl:sameAse ?gutenberg_subject] .""",
                      """<%s> dcterms:type [rdf:value ?gutenberg_media_type] .""",
                      "<%s> dcterms:rights ?gutenberg_rights .",
                      "<%s> dcterms:title ?gutenberg_title .",
                      "<%s> dcterms:issued ?gutenberg_issued .",
                      "<%s> dcterms:creator ?gutenberg_creator .",
                      "<%s> dcterms:license ?gutenberg_license .",
                      "<%s> dcterms:tableOfContents ?gutenberg_tableOfContents .",
                      "<%s> pgterms:marc010 ?gutenberg_marc010 .",
                      "<%s> pgterms:marc901 ?gutenberg_marc901 .",
                      """<%s> pgterms:bookshelf [rdf:value ?gutenberg_bookshelf] .""",
                      "<%s> pgterms:marc440 ?gutenberg_marc440 .",
                      "<%s> dcterms:description ?gutenberg_description .",
                      "<%s> marcrel:trl ?gutenberg_trl .",
                      "<%s> dcterms:alternative ?gutenberg_alternative .",
                      "<%s> marcrel:edt ?gutenberg_edt .",
                      "<%s> marcrel:aui ?gutenberg_aui .",
                      "<%s> marcrel:pbl ?gutenberg_pbl .",
                      "<%s> marcrel:ill ?gutenberg_ill .",
                      "<%s> marcrel:cmm ?gutenberg_cmm .",
                      "<%s> marcrel:com ?gutenberg_com .",
                      "<%s> marcrel:oth ?gutenberg_oth .",
                      "<%s> pgterms:marc260 ?gutenberg_marc260 .",
                      "<%s> marcrel:ctb ?gutenberg_ctb .",
                      "<%s> marcrel:ann ?gutenberg_ann .",
                      "<%s> marcrel:egr ?gutenberg_egr .",
                      "<%s> pgterms:marc508 ?gutenberg_marc508 .",
                      "<%s> pgterms:marc546 ?gutenberg_marc546 .",
                      "<%s> pgterms:marc902 ?gutenberg_marc902 .",
                      "<%s> pgterms:marc520 ?gutenberg_marc520 .",
                      "<%s> pgterms:marc903 ?gutenberg_marc903 .",
                      "<%s> pgterms:marc300 ?gutenberg_marc300 .",
                      "<%s> marcrel:adp ?gutenberg_adp .",
                      "<%s> marcrel:pht ?gutenberg_pht .",
                      "<%s> marcrel:unk ?gutenberg_unk .",
                      "<%s> marcrel:prt ?gutenberg_prt .",
                      "<%s> marcrel:prf ?gutenberg_prf .",
                      "<%s> pgterms:marc250 ?gutenberg_marc250 .",
                      "<%s> pgterms:marc020 ?gutenberg_marc020 .",
                      "<%s> marcrel:cmp ?gutenberg_cmp .",
                      "<%s> marcrel:dub ?gutenberg_dub .",
                      "<%s> marcrel:arr ?gutenberg_arr .",
                      "<%s> marcrel:trc ?gutenberg_trc .",
                      "<%s> marcrel:clb ?gutenberg_clb .",
                      "<%s> marcrel:aft ?gutenberg_aft .",
                      "<%s> marcrel:res ?gutenberg_res .",
                      "<%s> marcrel:art ?gutenberg_art .",
                      "<%s> owl:sameAs|foaf:isPrimaryTopicOf ?same_as  .",)

    _author_metadata = ("<%s> pgterms:alias ?aliases .",
                        "<%s> pgterms:birthdate ?birth_date .",
                        "<%s> pgterms:deathdate ?death_date .",
                        "<%s> owl:sameAs|foaf:isPrimaryTopicOf ?same_as .",
                        "<%s> pgterms:webpage ?web_pages .",
                        "<%s> rdf:type ?gutenberg_type .")

    def __init__(self, logs, sparql_endpoint="http://dhtk.unil.ch/gutenberg/sparql"):
        """Initialize tools with the SPARQL endpoint,
        such as an local instance of the Apache Jena Fuseki server.

        Parameters
        ----------
        logs: logging.Logger object from DHTK Settings
        sparql_endpoint: str
            URL of the triplet store containing Gutenberg Catalog triplets.
        """
        self._sparql_endpoint = SPARQLWrapper(sparql_endpoint)
        self.LOGS = logs

        self.LOGS.info(f"GUTENBERG: GutenbergData instantiated using SPARQL endpoint: {sparql_endpoint}")

    # Bookshelves
    _shelves = """?book_id pgterms:bookshelf [dcterms:title ?bookshelf] ."""
    def all_bookshelves(self, select = "SELECT DISTINCT ?bookshelf"):
        """Return all bookshelves in the store.

        This method doesn't use the standard SPARQL query, but a specific to get only bookshelves.

        Returns
        -------
        bookshelves : list(str)
            Each element is a string not strictly formatted.

        Example
        -------
        ::

            pprint(gutenberg_data.all_bookshelves())
            # ['Adventure',
            #  'Africa',
            #  'African American Writers',
            #  "Ainslee's",
            #  'American Revolutionary War',
            #  'Anarchism',
            #  'Animal',
            #  'Animals-Domestic',
            #  'Animals-Wild',
            #  'Animals-Wild-Birds',
            #  'Animals-Wild-Insects',
            #  'Animals-Wild-Mammals',
            #  ...
        """

        pattern = f"""
                WHERE {{
                    {self._shelves}
                }}
                ORDER BY ?bookshelf
                """
        query = self._namespace + select + pattern
        query = self._get_query_results(query)

        if "COUNT" in select:
            return query[0]["total"]
        return [result["bookshelf"] for result in query]

    def search_by_bookshelf(self, bookshelf):
        """Data in Gutenberg catalog all books corresponding to the given bookshelf string.

        The bookshelf is used as parameter in a SPARQL query.

        Parameters
        ----------
        bookshelf: str
            bookshelf in plain text, case-insensitive. It can be a part of the bookshelf.

        Returns
        -------
        books : list(dict)
            Each dict contains information a book:
            - author: the name of the author
            - author_id: the gutenberg id uri of the author
            - book_id: the gutenberg id uri of the book
            - language: the language of the book
            - title: the title of the book
            - bookshelf: the bookshelf found

        Example
        -------
        ::

            pprint(gutenberg_data.search_by_bookshelf("animal"))
            # [{'author': 'Abbott, Henry',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/37066',
            #   'book_id': 'http://www.gutenberg.org/ebooks/34672',
            #   'bookshelf': 'Animal',
            #   'language': 'en',
            #   'title': 'Fish Stories'},
            #  {'author': 'Abbott, Henry',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/37066',
            #   'book_id': 'http://www.gutenberg.org/ebooks/34672',
            #   'bookshelf': 'Animals-Wild',
            #   'language': 'en',
            #   'title': 'Fish Stories'},
            #  ...

        """
        self.LOGS.info(f"GUTENBERG: Searching bookshelf: {bookshelf}")

        select = "SELECT DISTINCT *"
        pattern =f"""
            WHERE {{
                {self._shelves}
                FILTER CONTAINS(lcase(str(?bookshelf)), "{bookshelf.lower()}")
                {self._books}   
                OPTIONAL {{ ?book_id dcterms:language [rdf:value ?language].}}             
            }}
            ORDER BY ?author ?title
            """
        query = self._namespace + select + pattern
        return self._get_query_results(query)

    # Subjects
    _subjects = """?book_id dcterms:subject [dcterms:title ?subject]."""
    def all_subjects(self, select= "SELECT DISTINCT ?subject"):
        """Return all subjects in the store.

        This method don't use the standard SPARQL query, but a specific to get only subjects.

        Returns
        -------
        subjects : list(str)
            Each element is a string not strictly formatted, but generally displayed like
            " Subject -- Sub-subject -- Sub-sub-subject" in English

        Example
        -------
        ::

            pprint(gutenberg_data.all_subjects())
            # ["'Abd al-Rahman Khan, Amir of Afghanistan, -1901",
            #  'A. J. Fuller (Ship)',
            #  'A. L. O. E., 1821-1893',
            #  'A1 Road (England and Scotland)',
            #  'A5 Road (England and Wales)',
            #  'AC',
            #  'AE',
            #  'AG',
            #  'ALGOL (Computer program language)',
            #  ...

        """
        pattern = f"""
            WHERE {{
                {self._subjects}
            }}
            ORDER BY ?subject
        """
        query = self._namespace + select + pattern
        query = self._get_query_results(query)

        if "COUNT" in select:
            return query[0]["total"]
        return [result["subject"] for result in query]

    def search_by_subject(self, subject, limit=0):
        """
        Data in Gutenberg catalog all books with given subject string.

        The subject is used as parameter in a SPARQL query. If no limit value is specified,
        the method returns all books with the given subject.

        Parameters
        ----------
        subject: str
            Subject in plain text, case-insensitive. It can be a part of the subject.
        limit: int
            Use to limit how many books are returned by the SPARQL query.

        Returns
        -------
        books : list of dict
            Each found book is described with a dictionary

        Example
        -------
        ::

            pprint(gutenberg_data.search_by_subject(
                "Charlemagne, Emperor, 742-814 -- Romances --"
            ))
            # [{'author': 'Bulfinch, Thomas',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/1179',
            #   'book_id': 'http://www.gutenberg.org/ebooks/4928',
            #   'language': 'en',
            #   'subject': 'Charlemagne, Emperor, 742-814 -- Romances -- Adaptations',
            #   'title': "Bulfinch's Mythology"},
            #  {'author': 'Bulfinch, Thomas',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/1179',
            #   'book_id': 'http://www.gutenberg.org/ebooks/56644',
            #   'language': 'en',
            #   'subject': 'Charlemagne, Emperor, 742-814 -- Romances -- Adaptations',
            #   'title': "Bulfinch's Mythology"
            #            'The Age of Fable; The Age of Chivalry; Legends of Charlemagne'}]

        """
        select = "SELECT DISTINCT *"
        pattern = f"""
                    WHERE {{
                        {self._subjects}
                        FILTER CONTAINS(lcase(str(?subject)), "{subject.lower()}")
                        {self._books}   
                        OPTIONAL {{ ?book_id dcterms:language [rdf:value ?language].}}          
                    }}
                    ORDER BY ?author ?title
                    """
        query = self._namespace + select + pattern
        if limit > 0:
            query += f"LIMIT {limit}"

        return self._get_query_results(query)


    # Authors
    _authors = """?book_id purl:creator ?author_id;
                        dcterms:type dcmitype:Text.
                  ?author_id pgterms:name ?author."""
    def all_authors(self, select = "SELECT DISTINCT ?author"):
        """
        Return all authors in the store.

        This method don't use the standard SPARQL query, but a specific to get only authors.

        Returns
        -------
        authors : list of tuples
            Each tuple contains the complete author's name followed by the author identifier.
            The author id is an URI, like "http://www.gutenberg.org/2009/agents/43546"

        Example
        -------
        ::

            pprint(gutenberg_data.all_authors())
            # [('Hugo, Victor', 'http://www.gutenberg.org/2009/agents/85'),
            #  ('Firkins, Ina Ten Eyck', 'http://www.gutenberg.org/2009/agents/7564'),
            #  ...

        """

        pattern = f"""
            WHERE {{
                {self._authors}
            }}
            ORDER BY ?author
        """
        query = self._namespace + select + pattern
        if "COUNT" in select:
            return self._get_query_results(query)[0]["total"]
        return [result["author"] for result in self._get_query_results(query)]

    def search_by_author(self, name, alias=None):
        """
        Data books in the Gutenberg catalog by author's name and last name.

        The standard SPARQL query is overwritten by a filter and by a sort instruction.

        Parameters
        ----------
        author_name : str
            Author's name, first name, last name or alias in plain text, case-insensitive.
            It can be a part of the author's name.


        Returns
        -------
        results : list(dict)
            Each dict contains information a book:
            - author: the name of the author
            - author_id: the gutenberg id uri of the author
            - book_id: the gutenberg id uri of the book
            - language: the language of the book
            - title: the title of the book

        Example
        -------
        ::

            pprint(gutenberg_data.search_by_author("Melville"))
            # [{'author': 'Baker, George M. (George Melville)',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/44486',
            #   'book_id': 'http://www.gutenberg.org/ebooks/49478',
            #   'language': 'en',
            #   'title': 'A Mysterious Disappearance: A Farce'},
            # ...
            #  {'author': 'Foster, Finley Melville Kendall',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/45056',
            #   'book_id': 'http://www.gutenberg.org/ebooks/48950',
            #   'language': 'en',
            #   'title': 'English Translations from the Greek: A Bibliographical Survey'},
            #   ...
            #  {'author': 'Melville, Herman',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/9',
            #   'book_id': 'http://www.gutenberg.org/ebooks/12384',
            #   'language': 'en',
            #   'title': 'Battle-Pieces and Aspects of the War'},
            #   ...
            pprint(gutenberg_data.search_by_author("Herman", "Melville"))
            # [{'author': 'Melville, Herman',
            #  'author_id': 'http://www.gutenberg.org/2009/agents/9',
            #  'book_id': 'http://www.gutenberg.org/ebooks/11231',
            #  'language': 'en',
            #  'title': 'Bartleby, the Scrivener: A Story of Wall-Street'},
            # {'author': 'Melville, Herman',
            #  'author_id': 'http://www.gutenberg.org/2009/agents/9',
            #  'book_id': 'http://www.gutenberg.org/ebooks/12384',
            #  'language': 'en',
            #  'title': 'Battle-Pieces and Aspects of the War'},
            # ...
        """

        # If alias is provided, looks for name AND alias
        # Otherwise assume the name might be an alias

        names = re.split('\W+', name)
        filter=""
        for name in names:
            filter += f'FILTER (CONTAINS(lcase(str(?author)), "{name.lower()}")'
            if alias is None:
                filter += f' ||  CONTAINS(lcase(str(?aliases)), "{name.lower()}")'
            filter += f")\n"
        if alias is not None:
            aliases = re.split('\W+', alias)
            for alias in aliases:
                filter += f'FILTER (CONTAINS(lcase(str(?aliases)), "{alias.lower()}"))\n'

        select =  "SELECT DISTINCT ?author ?aliases ?author_id"
        pattern = f"""   
            WHERE {{
                {self._authors}
                {filter}
                OPTIONAL {{ ?author_id pgterms:alias ?aliases. }}
            }}
            ORDER BY ?author
            """

        query = self._namespace + select + pattern

        return self._get_query_results(query)

    def get_author(self, id):
        """
        Create an author object with information collected from the Gutenberg Store.

        Parameters
        ----------
        id : str
            The author identifier is an URI, like 'http://www.gutenberg.org/2009/agents/408'

        Returns
        -------
        Author : dhtk.catalogs.gutenberg.author.GutenbergAuthor
            An instance of the class Author

        Example
        -------
        ::

            author = gutenberg_data.author_from_author_id(
                'http://www.gutenberg.org/2009/agents/8136'
            )
            author.print_info()
            # Thomas Hodgkin
            # Metadata    :
            #     - gutenberg_id: http://www.gutenberg.org/2009/agents/8136
            #     - id          : http://www.gutenberg.org/2009/agents/8136
            #     - gutenberg_name: Hodgkin, Thomas
            #     - gutenberg_aliases:
            #     - aliases     :
            #     - web_pages   :
            #             - http://en.wikipedia.org/wiki/Thomas_Hodgkin_(historian)
            #     - birth_date  :         1831
            #     - death_date  :         1913
        """

        select = "SELECT DISTINCT *"
        pattern = f"""
            WHERE {{
                <{id}> pgterms:name ?name . 
            }}
        """
        query = self._namespace + select + pattern
        query = self._get_query_results(query)[0]

        author = GutenbergAuthor(
            gutenberg_id=id,
            name=query["name"],
        )
        author.update_metadata(self.get_metadata(author))
        author.update_metadata({"bibliography": self.get_bibliography(id)})
        return author

    def get_bibliography(self, id):
        """
        To get all books written by an author.

        Parameters
        ----------
        id : str
            The author identifier is an URI, like 'http://www.gutenberg.org/2009/agents/408'

        Returns
        -------
        books : list of tuples
            Each tuple contains the book title and the book identifier..

        Example
        -------
        ::

            pprint(gutenberg_data.get_bibliography_from_author_id(
                'http://www.gutenberg.org/2009/agents/8136'
            ))
            # [(
            #     'Theodoric the Goth: Barbarian Champion of Civilisation',
            #     'http://www.gutenberg.org/ebooks/20063'
            # )]
        """
        select = "SELECT DISTINCT ?title"
        pattern = f"""
            WHERE {{
                ?book_id purl:creator <{id}> .
                {self._books}
            }}
            ORDER BY ?title
        """

        query = self._namespace + select + pattern
        return [result["title"] for result in self._get_query_results(query)]

    # Books
    _books = f"""?book_id purl:title ?title.
                {_authors}
                """

    def all_books(self, select = "SELECT DISTINCT ?title ?author"):
        """
        Return the title of all books in the store.

        This method don't use the standard query, but a specific to get only
        titles and book identifiers.

        Returns
        -------
        books : list of tuples
            Each tuple contains the book title followed by the book id.

        Example
        -------
        ::

            pprint(gutenberg_data.all_books())
            # [('!Tention: A Story of Boy-Life during the Peninsular War',
            #   'http://www.gutenberg.org/ebooks/21374'),
            #  ('"\'Tis Sixty Years Since"'
            #   "Address of Charles Francis Adams; Founders' Day, January 16, 1913",
            #   'http://www.gutenberg.org/ebooks/9996'),
            #  ('"1683-1920"'
            #   'The Fourteen Points and What Became of Them—Foreign Propaganda in the '
            #   'Public Schools—Rewriting the History of the United States—The Espionage Act '
            #   'and How It Worked—"Illegal and Indefensible Blockade" of the Central '
            #   'Powers—1,000,000 Victims of Starvation—Our Debt to France and to '
            #   'Germany—The War Vote in Congress—Truth About the Belgian Atrocities—Our '
            #   'Treaty with Germany and How Observed—The Alien Property '
            #   'Custodianship—Secret Will of Cecil Rhodes—Racial Strains in American '
            #   'Life—Germantown Settlement of 1683 and a Thousand Other Topics',
            #   'http://www.gutenberg.org/ebooks/50075'),
            #  ('"1812" Napoleon I in Russia', 'http://www.gutenberg.org/ebooks/51418'),
            #  ('"A Soldier Of The Empire"', 'http://www.gutenberg.org/ebooks/23014'),
            # ...
        """
        pattern = f"""
            WHERE {{
                {self._books}
            }}
            ORDER BY ?title
          """
        query = self._namespace + select + pattern
        query = self._get_query_results(query)

        if "COUNT" in select:
            return query[0]["total"]
        return [{"title":result['title'],"author":result['author']} for result in query]

    def search_by_title(self, title):
        """
        Data in Gutenberg catalog all books with given title string.


        Parameters
        ----------
        title: str
            Title in plain text, case-insensitive. It can be a part of the title.

        Returns
        -------
        books : list(dict)
            Each found book is described with a dictionary:
            - author: the name of the author
            - author_id: the gutenberg id uri of the author
            - book_id: the gutenberg id uri of the book
            - language: the language of the book
            - title: the title of the book


        Example
        -------
        ::

            pprint(gutenberg_data.search_by_title("Lord of the"))
            # [{'author': 'Benson, Robert Hugh',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/4052',
            #   'book_id': 'http://www.gutenberg.org/ebooks/14021',
            #   'language': 'en',
            #   'title': 'Lord of the World'},
            #  {'author': 'Carlile, Richard',
            #   'author_id': 'http://www.gutenberg.org/2009/agents/39431',
            #   'book_id': 'http://www.gutenberg.org/ebooks/40211',
            #   'language': 'en',
            # ...

        """
        select = "SELECT DISTINCT ?book_id ?title ?author_id ?author ?language"
        pattern = f"""
            WHERE {{
              {self._books}
              OPTIONAL {{?book_id dcterms:language [rdf:value ?language].}}
              FILTER CONTAINS(lcase(str(?title)), {repr(title)})
            }}
            ORDER BY ?author ?title
            """
        query = self._namespace + select + pattern
        return self._get_query_results(query)

    def get_book(self, book_id, author=None):
        """
        Create a book object with information collected from the Gutenberg Store.

        Parameters
        ----------
        book_id : str
            The book identifier is an URI, like 'http://www.gutenberg.org/ebooks/20063'

        Returns
        -------
        Book : dhtk.catalogs.gutenberg.author.GutenbergBook
            An instance of the class GutenbergBook

        Example
        --------
        ::

            book = gutenberg_data.book_from_book_id('http://www.gutenberg.org/ebooks/20063')
            book.print_info()
            # Title       : Theodoric the Goth: Barbarian Champion of Civilisation
            # Author      : Thomas Hodgkin
            # Metadata    :
            #     - gutenberg_id: http://www.gutenberg.org/ebooks/20063
        """

        select = "SELECT DISTINCT *"
        pattern = f"""
            WHERE {{
                <{book_id}> purl:title ?title; 
                    purl:creator ?author_id;
                    dcterms:type dcmitype:Text.          
            }}"""

        query = self._namespace + select + pattern
        book = self._get_query_results(query)[0]

        if not author:
            author = self.get_author(book["author_id"])

        metadata = self.bookshelves_subjects(book_id)

        book = GutenbergBook(
            gutenberg_id=book_id,
            title=book["title"],
            subject=metadata["subjects"] or None,
            bookshelf=metadata["bookshelves"] or None,
            author=author
        )
        book.update_metadata(self.get_metadata(book))
        return book

    def bookshelves_subjects(self, book_id):
        """
        Return the bookshelves and the subjects of the given book, designated by his identifier.

        Parameters
        ----------
        book_id: str
            A Gutenberg book identifier. Is an URI, like "http://www.gutenberg.org/ebooks/10053"

        Returns
        -------
        bookshelves and subjects: tuple of lists
            In the first element of the tuple, there is a list of bookshelves.
            In the second, a list of subjects.

        Example
        -------
        ::

            pprint(gutenberg_data.bookshelves_subjects(
                'http://www.gutenberg.org/ebooks/23434'
            ))
            # The corresponding book :  An Elementary Study of Insects by Leonard Haseman
            # {'bookshelves': ['Animals-Wild-Insects', 'Biology'],
            #  'subjects': ['Insects', 'QL']}

        """
        select = "SELECT DISTINCT ?subject ?bookshelf"
        pattern = f"""
            WHERE {{
                <{book_id}> dcterms:subject [dcterms:title ?subject];
                    pgterms:bookshelf [dcterms:title ?bookshelf] ;
                    dcterms:type dcmitype:Text.                             
            }}
            ORDER BY ?subject
            """
        query = self._namespace + select + pattern
        query = self._get_query_results(query)

        subjects = [result["subject"] for result in query]
        bookshelves = [result["bookshelf"] for result in query]

        return {"bookshelves": set(bookshelves), "subjects": set(subjects)}

    # Queries
    def _get_query_results(self, query):
        """Use a SPARQL query to get results from the triplet store.

        Parameters
        ----------
        query: str
            A structured string in the SPARQL language used to ask the triplet store.

        Returns
        -------
        results: list of dict
            Each dict contains with requested information as key-value.
        """
        self.LOGS.debug(f"GUTENBERG: Executing query: \n{query}")

        sparql = self._sparql_endpoint

        sparql.setQuery(query)
        sparql.setReturnFormat(JSON)
        # TODO: handle external server better than this, please:
        query_results = sparql.queryAndConvert()

        results = list()
        for entry in query_results["results"]["bindings"]:
            formatted_entry = dict()
            for key, value in entry.items():
                formatted_entry[key] = value["value"]
            results.append(formatted_entry)
        return results

    def get_metadata(self, item):
        """Get metadata about the book that is present in the catalog.

        Parameters
        ----------
        item : An object having an entry "gutenberg_id" in the results of the method get_metadata().
            The metadata of these tools must contain an entry called: "gutenberg_id"

        Returns
        -------
        A dictionary of metadata.
        Example
        -------
        ::

            book = gutenberg_data.book_from_book_id("http://www.gutenberg.org/ebooks/40431")
            pprint(gutenberg_data.get_metadata(book))
            # {'gutenberg_creator': 'http://www.gutenberg.org/2009/agents/40622',
            #  'gutenberg_downloads': ['10', '13', '31', '39'],
            #  'gutenberg_hasFormat': ['http://www.gutenberg.org/ebooks/40431.kindle.images',
            #                          'http://www.gutenberg.org/files/40431/40431-h/40431-h.htm',
            #                          'http://www.gutenberg.org/files/40431/40431.txt',
            #                          'http://www.gutenberg.org/ebooks/40431.epub.images',
            #                          'http://www.gutenberg.org/files/40431/40431.zip',
            #                          'http://www.gutenberg.org/ebooks/40431.txt.utf-8',
            #                          'http://www.gutenberg.org/files/40431/40431-8.txt',
            #                          'http://www.gutenberg.org/ebooks/40431.epub.noimages',
            #                          'http://www.gutenberg.org/files/40431/40431-8.zip',
            #                          'http://www.gutenberg.org/files/40431/40431-h.zip',
            #                          'http://www.gutenberg.org/ebooks/40431.kindle.noimages',
            #                          'http://www.gutenberg.org/ebooks/40431.rdf'],
            #  'gutenberg_issued': '2012-08-07',
            #  'gutenberg_language': 'en',
            #  'gutenberg_license': 'http://www.gutenberg.org/license',
            #  'gutenberg_media_type': 'Text',
            #  'gutenberg_publisher': 'Project Gutenberg',
            #  'gutenberg_rights': 'Public domain in the USA.',
            #  'gutenberg_subject': ['PS', 'Fiction'],
            #  'gutenberg_title': 'Miss Hildreth: A Novel, Volume 1',
            #  'gutenberg_type': 'http://www.gutenberg.org/2009/pgterms/ebook'}

            pprint(gutenberg_data.get_metadata(book.get_author()))
            # {'gutenberg_birth_date': '1852',
            #  'gutenberg_death_date': '1894',
            #  'gutenberg_name': 'Stevens, Augusta de Grasse',
            #  'gutenberg_type': 'http://www.gutenberg.org/2009/pgterms/agent'}

        """

        query_results = self._metadata_query(item)

        metadata = dict()
        for result in query_results:
            result_count = len(result)
            if result_count == 1:
                for key in result[0].keys():
                    metadata[key] = result[0][key]
            elif result_count > 1:
                for key in result[0].keys():
                    metadata[key] = [entry[key] for entry in result]

        return metadata

    def _metadata_query(self, item):
        """
        Helper function to get metadata for different item types.

        :param item: An object having an entry "gutenberg_id" in the results of the method
            get_metadata().
            The metadata of these tools must contain an entry called: "gutenberg_id"
        :return: list()
                 The query results of the metadata query.
        """
        query = self._namespace
        query += """ SELECT DISTINCT *
            WHERE {
            """
        query_results = []
        if isinstance(item, GutenbergBook):
            book_id = item.get_book_id()
            for metadata in self._book_metadata:
                query_results.append(self._get_query_results(query + metadata % book_id + "}"))
            return query_results

        if isinstance(item, GutenbergAuthor):
           author_id = item.get_gutenberg_id()
           for metadata in self._author_metadata:
               query_results.append(self._get_query_results(query + metadata % author_id + "}"))
        return query_results

        raise TypeError

    def statistics(self):
        """
        Print information about the Gutenberg catalog.

        Returns
        -------
        statistics : str
            Formatted string of different statistics.
            Subject counts sub-subjects too.

        Notes
        -----
        This method is relatively slow due to the fact that it inspects the whole Gutenberg RDF.

        Example
        --------
        ::

            gutenberg_data.statistics()
            # number of books        :     60101
            # number of authors      :     20908
            # number of bookshelves  :       335
            # number of subjects     :     17524

        """
        statistics = dict()
        statistics["number_of_books"] = self.all_books(select="SELECT (COUNT(DISTINCT ?title) as ?total)")
        statistics["number_of_authors"] = self.all_authors(select="SELECT (COUNT(DISTINCT ?author) as ?total)")
        statistics["number_of_bookshelves"] = self.all_bookshelves(select="SELECT (COUNT(DISTINCT ?bookshelf) as ?total)")
        statistics["number_of_subjects"] = self.all_subjects(select="SELECT (COUNT(DISTINCT ?subject) as ?total)")
        text = ""
        for key, value in statistics.items():
            text += f"\n{key.replace('_', ' '):23}:\t {value:>5}"

        return text
