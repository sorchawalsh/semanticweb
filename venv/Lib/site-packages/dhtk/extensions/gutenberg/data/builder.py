#GETTING GUTENBERG
# TODO: Use rdfpro : It is a 1000 time faster than rdflib

def get_metadata(self):
    """

    Returns
    -------

    """
    self.MANAGERS.SYSTEM.download_files(self.url,
                                        configuration={"file": "downloads", "setting": "gutenberg"},
                                        desc="Downloading Gutenberg.org metadata")

    self.graph, log = self.MANAGERS.SYSTEM.unpack_archive(g=self.graph,
                                                          configuration={"file": "gutenberg", "setting": "books"},
                                                          desc="Unpacking Gutenberg.org metadata",
                                                          archive_type="r:bz2")

    self._process_graph(log)
    self.MANAGERS.SYSTEM.serialize(self.graph, len(self.MANAGERS.SYSTEM.unpacked_files), file_name=self.master)


def unpack_archive(self, g=rdflib.Graph(), configuration=None, desc="Unpacking archive", archive_type="r:bz2"):
    if configuration is None:
        configuration = {"file": "downloads", "setting": "files"}

    # Capture rdflib.graph.parse logs to identify broken URIs
    logger = logging.getLogger("rdflib.term")
    log_capture_string = io.StringIO()
    ch = logging.StreamHandler(log_capture_string)
    logger.addHandler(ch)

    file_names = []

    for archive in self.last_download:
        print("Opening {}".format(archive))
        tar = tarfile.open(archive, archive_type)
        files = tar.getmembers()

        for member in tqdm.tqdm(files, desc=desc):
            member.name = os.path.basename(member.name)  # Cleans the folder structure
            tar.extract(member, self.wd)

            g = self._merge_graphs(self.wd / member.name, g)

            file_names.append(member.name)

        tar.close()
        print("Removing {} ".format(archive))
        subprocess.check_call(["rm", archive])
    log = log_capture_string.getvalue()

    # Save to config
    self.MANAGERS.CONFIG.add_record(configuration, value=file_names, unique=True)
    self.unpacked_files = file_names

    return g, log


def _merge_graphs(file, graph):
    graph.parse(str(file), format="xml", encoding='utf-8')
    os.remove(file)
    return graph

def serialize(self, graph, n_files, file_name="master.rdf"):
    print("{} triples merged from {} RDF graphs".format(len(graph), n_files))

    graph.serialize(destination=str(self.wd / file_name), format='xml', encoding="utf-8")

    print("Saved to {}".format(self.wd / file_name))

# PROCESSING GUTENBERG
def _process_graph(self, log):
    self._fix_uri(log)
    self._fix_bookshelves()
    self._fix_mime()
    self._fix_langs()
    self._fix_table_contents()
    self._fix_dcmi()
    self._fix_lib_congress()


def _fix_uri(self, log):
    if log:
        broken = re.sub("does not look like a valid URI.*", "", log)
        broken = broken.split("\n")
        broken = [uri.strip() for uri in set(broken) if uri]

        for uri in broken:
            uri_fixed = urllib.parse.quote(uri, safe="%/:=&?~#+!$,;'@()*[]")
            uri_fixed = rdflib.URIRef(uri_fixed)
            uri = rdflib.URIRef(uri)

            # subjects
            for p, o in self.graph[uri]:
                self.graph.remove((uri, p, o))
                self.graph.add((uri_fixed, p, o))
            # predicates
            for s, o in self.graph[:uri]:
                self.graph.remove((s, uri, o))
                self.graph.add((s, uri_fixed, o))
            # tools
            for s, p in self.graph[::uri]:
                self.graph.remove((s, p, uri))
                self.graph.add((s, p, uri_fixed))


def _fix_bookshelves(self):
    dhtk = rdflib.Namespace('http://dhtk.unil.ch/data/')

    self.graph.bind("pgterms", rdflib.Namespace('http://www.gutenberg.org/2009/pgterms/'))
    self.graph.bind("rdf", rdflib.Namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'))
    self.graph.bind("xsd", rdflib.Namespace('http://www.w3.org/2001/XMLSchema#'))
    self.graph.bind("dct", rdflib.Namespace('http://purl.org/dc/terms/'))
    self.graph.bind("dhtk", dhtk)

    qres = self.graph.query('''SELECT DISTINCT ?p ?v
                  WHERE {{
                      ?x pgterms:bookshelf [ ?p ?v ]
                  }}''')
    for p, v in qres:

        if rdflib.RDF.value == rdflib.URIRef(p):
            shelfname = v
            table = str.maketrans('', '', string.punctuation)
            slug = [w.translate(table) for w in shelfname]
            slug = ''.join(slug)
            slug = unidecode.unidecode(slug).lower().replace(' ', '_')
            shelf = dhtk['/'.join(['collection', 'gutenberg', slug])]

            # WARN translate Bookshelf for non-English ones (e.g. PT Prateleira)
            fix = '''
                  DELETE {{
                      ?x pgterms:bookshelf ?b . 
                      ?b rdf:value "{0}" ; 
                          <http://purl.org/dc/dcam/memberOf> ?t .
                      }}
                  INSERT {{
                      ?x pgterms:bookshelf <{1}> . 
                      <{1}> dct:title "{0}" ; 
                          rdfs:seeAlso ?wiki ; 
                          a ?t .
                      }}
                  WHERE {{
                      ?x pgterms:bookshelf ?b .
                      ?b rdf:value "{0}" ; 
                          <http://purl.org/dc/dcam/memberOf> ?t .
                      BIND(STRDT(CONCAT("https://www.gutenberg.org/wiki/","{0}","_(Bookshelf)"), xsd:anyURI) as ?test)    
                      }}
                  '''.format(shelfname, shelf)

            self.graph._update(fix)


def _fix_mime(self):
    dhtk = rdflib.Namespace('http://dhtk.unil.ch/data/')
    uwa = rdflib.Namespace('http://www.w3.org/2007/uwa/context/common.owl#')

    self.graph.bind("dhtk", dhtk)
    self.graph.bind("uwa", uwa)
    self.graph.bind("rdf", rdflib.Namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'))
    self.graph.bind("xsd", rdflib.Namespace('http://www.w3.org/2001/XMLSchema#'))
    self.graph.bind("dct", rdflib.Namespace('http://purl.org/dc/terms/'))
    self.graph.bind("nie", rdflib.Namespace('http://www.semanticdesktop.org/ontologies/2007/01/19/nie#'))

    qres = self.graph.query('''
                  SELECT DISTINCT ?p ?v
                  WHERE {{
                    ?x dct:format [ ?p ?v ]
                  }}''')
    for p, v in qres:
        if rdflib.RDF.value == rdflib.URIRef(p):

            content_type = v
            mimetype, options = cgi.parse_header(content_type)

            mime = rdflib.URIRef('http://www.iana.org/assignments/media-types/' + mimetype)
            if 'charset' in options and options['charset']:
                chst = options['charset']
                charset = uwa['CharacterSet_' + chst.upper()]
                uri_format = dhtk['/'.join(['format', urllib.parse.quote(mimetype, safe=''), 'charset', chst])]
                insert = '''
                          ?x dct:format <{0}> .
                          <{0}> a uwa:ContentType
                             ; uwa:contentTypeName "{1}"^^xsd:string
                             ; nie:mimeType <{2}>
                             ; nie:characterSet <{3}> .
                          <{2}> a uwa:ContentType
                             ; uwa:contentTypeName "{4}"^^xsd:string
                             ; ?p1 ?y1 .
                          <{3}> a uwa:CharacterSet
                             ; uwa:charsetName "{5}"^^xsd:string .
                             '''.format(uri_format, content_type, mime, charset, mimetype, chst)
            else:
                uri_format = mime
                insert = '''
                          ?x dct:format <{0}> .
                          <{0}> a uwa:ContentType
                             ; uwa:contentTypeName "{1}"^^xsd:string
                             ; ?p1 ?y1  .
                          '''.format(uri_format, mimetype)

            fix = '''
                      DELETE {{ 
                          ?x dct:format ?f . 

                          ?f rdf:value "{1}"^^dct:IMT ; 
                              ?p ?o
                      }}
                      INSERT {{ 
                          {0}
                      }}
                      WHERE {{
                          ?x dct:format ?f . 
                          ?f rdf:value "{1}"^^dct:IMT ; 
                              ?p ?o 

                          FILTER ( ?p != rdf:value )
                      }}
                      '''.format(insert, content_type)
            self.graph._update(fix)


def _fix_langs(self):
    """Creates one URI per ISO-639 (1 or 2) entry of each language
    using Library of Congress URIs, which align 639-1 and 639-2
    through skos:exactMatch
    """
    self.graph.bind("dc", rdflib.Namespace('http://purl.org/dc/elements/1.1/'))
    self.graph.bind("dct", rdflib.Namespace('http://purl.org/dc/terms/'))
    self.graph.bind("rdf", rdflib.Namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns'))

    fix = '''
          DELETE {
             ?x dct:language ?b . 
             ?b rdf:value ?lang .
          }
          INSERT {
             ?x dct:language ?u . 
             ?u rdf:value ?l .
          }
          WHERE {
             ?x dct:language ?b . 
             ?b rdf:value ?lang .

             BIND(IRI(
                  CONCAT("http://id.loc.gov/vocabulary/iso639-", 
                      IF(STRLEN(STR(?lang))=2, "1", "2"),
                      "/", 
                      STR(?lang))) as ?u)
             BIND(STRDT(STR(?lang), <http://purl.org/dc/terms/RFC4646>) as ?l )
          }'''
    self.graph._update(fix)

# SOMETHING WRONG WITH THIS ONE ON THE FULL DATA
# tests on
# https://gitlab.com/neves.ces/bnf_project/-/blob/d3d2d1b40d7c6243481c4bf97bc48184e358d905/tests/process_gutenberg.ipynb
def _fix_table_contents(self):
    self.graph.bind("dct", rdflib.Namespace('http://purl.org/dc/terms/'))
    self.graph.bind("fabio", rdflib.Namespace("http://purl.org/spar/fabio/"))

    qres = self.graph.query('''
                  SELECT DISTINCT ?book ?toc
                  WHERE {{
                    ?book dct:tableOfContents ?toc
                  }}''')
    for book, toc in qres:
        headings = toc.split(' -- ')
        toc = rdflib.URIRef('#'.join([book, '_toc']))
        insert = '''
                  <{0}> dct:tableOfContents <{1}> .
                  <{1}> a fabio:TableOfContents .
                  '''.format(book, toc)

        for i, h in enumerate(headings):
            head = h.strip().replace('"', '\\"')
            chap = rdflib.URIRef('#'.join([book, '_chapter-' + str(i + 1)]))
            # Whats the point of a blank node on the first line?
            #                 insert += '''
            #                     <{0}> rdf:_{1} <{2}> ;
            #                         rdf:member <{2}> .
            #                     <{2}> dct:title """{3}"""
            #                     '''.format(toc, i+1, chap, head)
            insert += '''
                      <{0}> rdf:member <{1}> . 
                      <{1}> dct:title """{2}""" .
                      '''.format(toc, chap, head)

        fix = '''
              DELETE {{
                  <{0}> dct:tableOfContents ?toc
              }}
              INSERT {{
                  {1}
              }}
              WHERE {{ 
                  <{0}> dct:tableOfContents ?toc
              }}
              '''.format(book, insert)

        self.graph._update(fix)


def _fix_dcmi(self):
    self.graph.bind("dct", rdflib.Namespace('http://purl.org/dc/terms/'))
    self.graph.bind("dcam", rdflib.Namespace("http://purl.org/dc/dcam/"))
    self.graph.bind("rdf", rdflib.Namespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#'))
    self.graph.bind("dmci", rdflib.Namespace('http://purl.org/dc/terms/DCMIType/'))

    # DCMIType
    qres = self.graph.query('''
                  SELECT DISTINCT ?t ?v
                  WHERE {{ 
                  ?x dct:type ?b . 
                  ?b dcam:memberOf ?t ;
                      rdf:value ?v
                  }}''')

    for t, v in qres:
        mcmi_type = "dmci:" + v

        fix = '''
              DELETE {{ 
                  ?x dct:type ?b . 
                  ?b dcam:memberOf <{0}> ;
                      rdf:value '{1}' . 
              }}
              INSERT {{
                  ?x dcam:memberOf {2} .

              }}
              WHERE {{ 
                  ?x dct:type ?b . 
                  ?b dcam:memberOf <{0}> ;
                      rdf:value '{1}' .
              }}'''.format(t, v, mcmi_type)

        self.graph._update(fix)


def _fix_lib_congress(self):
    self.graph.bind("lcc", rdflib.Namespace('http://purl.org/dc/terms/LCC/'))
    self.graph.bind("lcsh", rdflib.Namespace('http://purl.org/dc/terms/LCSH/'))

    qres = self.graph.query('''
                  SELECT DISTINCT ?t ?v
                  WHERE {{ 
                  ?x dct:subject ?b . 
                  ?b dcam:memberOf ?t ;
                      rdf:value ?v
                  }}''')

    for t, v in qres:

        if "LCC" in t:
            lcc_type = "lcc:" + v

        elif "LCSH" in t:
            lcc_type = "lcsh:" + urllib.parse.quote(v, safe="%/:=&?~#+!$,;'@()*[]")

        else:
            lcc_type = None

        if lcc_type:
            fix = '''
                  DELETE {{ 
                      ?x dct:subject ?b . 
                      ?b dcam:memberOf <{0}> ;
                        rdf:value "{1}" .
                  }}
                  INSERT {{
                     ?x dct:subject ?b . 
                     ?b dcam:memberOf {2} .
                  }}
                  WHERE {{
                     ?x dct:subject ?b .
                     b dcam:memberOf <{0}> ;
                         rdf:value "{1}" .
                  }}'''.format(t, v, lcc_type)

            self.graph._update(fix)

# DEDUCE ONTOLOGY

def owl_test():
    """
    Trying to automatically extract class information from triples

    check:
    https://gitlab.com/neves.ces/bnf_project/-/blob/d3d2d1b40d7c6243481c4bf97bc48184e358d905/Gutenberg_process.ipynb
    """
    import owlready2
    onto = owlready2.get_ontology(base_iri="master.rdf")
    onto._load()
    get_ontology("master.rdf#")

    with onto:
        class Drug(owlready2.Thing):
            pass

    # Class constructors
    def constructor(self, arg):
        self.constructor_arg = arg


    def define_class(name, arg):
        with onto:
            type(name, (owlready2.Thing,), {"__init__": constructor})

    define_class("test", 1)
    list(onto.classes())
