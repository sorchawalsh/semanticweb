"""Contains the GutenbergAuthor Class."""

import re
import copy
from nameparser import HumanName
from nameparser.config.titles import FIRST_NAME_TITLES
from dhtk.extensions.templates.author import Author

class GutenbergAuthor(Author):
    """
    The class for an author extended with variables from the gutenberg project.
    Child of the generic Author class.

    Example
    --------
    ::

        from pprint import pprint
        from  dhtk.catalogs.gutenberg.author import GutenbergAuthor

        # Create an author manually.
        adam_smith_author = GutenbergAuthor(
            gutenberg_id='http://www.gutenberg.org/2009/agents/1158',
            name='Smith, Adam'
        )

        # create an author form the gutenberg repository

        from dhtk.catalogs.gutenberg.data import GutenbergData

        database = GutenbergData()
        database.search_author_by_name("Adam", "Smith")
        # [('Smith, Adam', 'http://www.gutenberg.org/2009/agents/1158'),
        #  ('Smith, George Adam', 'http://www.gutenberg.org/2009/agents/5016')]

        adam_smith_author_pg = database.author_from_author_id(
            'http://www.gutenberg.org/2009/agents/1158'
        )

        adam_smith_author_pg.print_info()
        # Adam Smith
        # Metadata    :
        #     - gutenberg_id: http://www.gutenberg.org/2009/agents/1158
        #     - id          : http://www.gutenberg.org/2009/agents/1158
        #     - gutenberg_name:  Smith, Adam
        #     - gutenberg_aliases:
        #     - aliases     :
        #     - web_pages   :
        #             - http://en.wikipedia.org/wiki/Adam_Smith
        #     - birth_date  :         1723
        #     - death_date  :         1790

    """

    def __init__( self, gutenberg_id, name, aliases=None, web_pages=None, same_as=None, **kwargs):
        """
        Init function of GutenbergAuthor.

        Notes
        -----
        Implement the Abstract Author class and extend it with the gutenberg id,
        the eventual alias(es) and the eventual web page(s) of the author.
        Converts name into a HumanName object with convert_name.

        Parameters
        ----------
        gutenberg_id : str
            URI of the gutenberg author in the Gutenberg RDF.
        name : str
            Name of the author.
        aliases : set(str), default None
            Eventual aliases of the author.
        web_pages : set(str), default None
            Eventual web pages of the author.
        """
        if same_as is None:
            same_as = dict()
        id_format = re.compile(r"http://www.gutenberg.org/2009/agents/\d+$")
        if not id_format.fullmatch(gutenberg_id):
            raise ReferenceError("This gutenberg id is not valid! %s" % gutenberg_id)
        self.metadata["gutenberg_id"] = gutenberg_id
        self.metadata["id"] = gutenberg_id

        self.metadata["gutenberg_name"] = name

        if not isinstance(aliases, set):
            aliases = set()
        self.metadata["aliases"] = aliases

        if not isinstance(web_pages, set):
            web_pages = set()
        self.metadata["web_pages"] = web_pages

        # Add saint to nameparser's FIRST_NAME_TITLES
        FIRST_NAME_TITLES.add("saint")
        name = self.convert_name(name)

        # LOGGER.debug("converting aliases names: %s", ", ".join(aliases))
        self.metadata["aliases"] = {str(self.convert_name(alias)) for alias in aliases}
        # LOGGER.debug("aliases: %s", ", ".join(self.metadata["aliases"]))

        if str(name) in self.metadata["aliases"]:
            # LOGGER.debug("removing '%s' from %s", str(name), ", ".join(self.metadata["aliases"]))
            self.metadata["aliases"].remove(str(name))

        metadata = copy.copy(self.metadata)
        super().__init__(
            name,
            same_as=same_as,
            metadata=metadata,
            **kwargs
        )

    def convert_name(self, human_name):
        """
        Convert human_name string containing into a HumanName object.

        Notes
        -----
        Is done in the init for every GutenbergAuthor object with initial string parameter "name".

        Parameters
        ----------
        human_name : str
            Author's name in a string.

        Returns
        -------
        human_name : nameparser.HumanName
            Author's name being a nameparser.HumanName object.
        """

        human_name = HumanName(human_name)
        if human_name.suffix:
            self.metadata["gutenberg_name_suffix"] = human_name.suffix
            human_name.suffix = ""
        if human_name.nickname:
            # LOGGER.debug("%s nickname: %s", str(human_name), human_name.nickname)
            no_nickname = copy.copy(human_name)
            no_nickname.nickname = ""
            first_name_match = re.match(
                re.sub(r"(([A-Z])[a-z]*[.])", r"\2\\w+", human_name.first, re.UNICODE),
                human_name.nickname,
                re.UNICODE
            )
            # LOGGER.debug(
            #     "%s, %s",
            #     re.sub(
            #         r"(([A-Z])[a-z]*[.])", r"\2\\w+",
            #         human_name.first,
            #         re.UNICODE
            #     ),
            #     human_name.nickname
            # )
            if first_name_match and len(first_name_match.group(0)) >= len(human_name.first):
                human_name.first = first_name_match.group(0)
                human_name.nickname = human_name.nickname[len(human_name.first):].strip()
                # LOGGER.debug("Adding %s to aliases", str(no_nickname))
                self.metadata["aliases"] = set([str(no_nickname)])
            middle_name_match = re.match(
                re.sub(r"(([A-Z])[a-z]*[.])", r"\2\\w+", human_name.middle, re.UNICODE),
                human_name.nickname,
                re.UNICODE
            )
            # LOGGER.debug(
            #     "%s, %s",
            #     re.sub(
            #         r"(([A-Z])[a-z]*[.])", r"\2\\w+",
            #         human_name.middle, re.UNICODE
            #     ),
            #     human_name.nickname
            # )
            if middle_name_match and len(middle_name_match.group(0)) >= len(human_name.middle):
                human_name.middle = middle_name_match.group(0)
                human_name.nickname = human_name.nickname[len(human_name.middle):].strip()
                # LOGGER.debug("Adding %s to aliases", str(no_nickname))
                self.metadata["aliases"].add(str(no_nickname))
        return human_name

    def get_gutenberg_id(self):
        """
        Get the gutenberg id url of the author.

        Returns
        -------
        gutenberg_id : str
            The gutenberg id of the author.

        Example
        -------
        We pick the author Adam Smith instanced in GutenbergAuthor and get_gutenberg_id it
        returns the string: "http://www.gutenberg.org/2009/agents/1158".
        ::

            adam_smith_author_pg.get_gutenberg_id()
            # 'http://www.gutenberg.org/2009/agents/1158'
        """
        return self.metadata["gutenberg_id"]

    def __eq__(self, other):
        """
        Equality function between authors.

        Notes
        -----
        Test the equality of the two authors. Using the gutenberg_id if other is an instance of
        GutenbergAuthor. If not, it uses the dhtk.common.author.Author.__eq__() method that uses the
        author's names (first, last) and its birth date.

        Parameters
        ----------
        other : An instance of dhtk.common.author.Author or cof its child-classes.

        Returns
        -------
        equality : bool
            A bool that tells if the authors are the same or not.

        """
        if isinstance(other, GutenbergAuthor):
            equals = self.get_gutenberg_id() == other.get_gutenberg_id()
        else:
            equals = super().__eq__(other)
        return equals

    def __hash__(self):
        """
        Return hash for the author.

        Returns
        -------
        hash : int
            The hash value for the author.
        """
        return hash((self.get_first_name() + self.get_last_name() + self.get_birth_date()))

    def __repr__(self):
        """

        Returns
        -------
        object_str : String representing the object
        """

        return  f"<Author: {self.get_last_name()}, {self.get_first_name()} ({self.get_gutenberg_id()}>)"
